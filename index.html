<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WISP Proxy (Render)</title>
  <style>
    body { margin:0; font-family:sans-serif; background:#111; color:#eee; }
    #bar { display:flex; padding:6px; background:#222; }
    #url { flex:1; padding:6px; border:none; border-radius:4px; }
    #go { margin-left:6px; padding:6px 12px; border:none; background:#4cafef; color:#fff; border-radius:4px; cursor:pointer; }
    #viewer { width:100%; height:calc(100vh - 42px); border:none; background:white; }
    #status { padding:6px; background:#444; color:#fff; font-size:0.9em; text-align:center; }
  </style>
</head>
<body>
  <div id="bar">
    <input id="url" type="text" placeholder="https://example.com" />
    <button id="go">Go</button>
  </div>
  <div id="status">WebSocket status: Not connected</div>
  <iframe id="viewer" sandbox="allow-scripts allow-forms allow-same-origin"></iframe>

<script>
(() => {
  const WISP_URL = "wss://wisp-server-mn4z.onrender.com";
  let ws;
  const urlBox = document.getElementById("url");
  const goBtn = document.getElementById("go");
  const statusDiv = document.getElementById("status");
  const viewer = document.getElementById("viewer");

  const pending = {};
  let reqId = 0;

  function connect(cb) {
    if (ws && ws.readyState === WebSocket.OPEN) {
      cb();
      return;
    }
    statusDiv.textContent = "WebSocket status: Connecting...";
    ws = new WebSocket(WISP_URL);
    ws.onopen = () => {
      statusDiv.textContent = "WebSocket status: Connected";
      cb();
    };
    ws.onclose = () => {
      statusDiv.textContent = "WebSocket status: Closed";
    };
    ws.onerror = (err) => {
      statusDiv.textContent = "WebSocket status: Error";
      console.error("WebSocket error:", err);
    };
    ws.onmessage = (msg) => {
      try {
        const obj = JSON.parse(msg.data);
        if (obj.id != null && pending[obj.id]) {
          const body = obj.body || (obj.body_b64 ? atob(obj.body_b64) : "");
          // Write into iframe
          const doc = viewer.contentDocument || viewer.contentWindow.document;
          doc.open();
          doc.write(body);
          doc.close();
          interceptLinks(doc);
          injectXHR(doc);
          pending[obj.id]();
          delete pending[obj.id];
        }
      } catch (e) {
        console.error("Failed to parse message:", e);
      }
    };
  }

  function sendFetch(url) {
    return new Promise(resolve => {
      connect(() => {
        const id = reqId++;
        pending[id] = resolve;
        ws.send(JSON.stringify({ id, action: "fetch", url }));
      });
    });
  }

  goBtn.addEventListener("click", () => {
    const target = urlBox.value.trim();
    if (!target.startsWith("http")) {
      alert("Enter full URL including http(s)");
      return;
    }
    sendFetch(target);
  });

  urlBox.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      goBtn.click();
    }
  });

  // Intercept links inside iframe
  function interceptLinks(doc) {
    doc.querySelectorAll("a[href]").forEach(a => {
      a.addEventListener("click", e => {
        e.preventDefault();
        const href = a.getAttribute("href");
        const newUrl = new URL(href, urlBox.value).href;
        urlBox.value = newUrl;
        sendFetch(newUrl);
      });
    });
  }

  // Override fetch/XHR inside iframe (basic)
  function injectXHR(doc) {
    const win = viewer.contentWindow;
    if (!win) return;
    win.fetch = async (input, init={}) => {
      const url = typeof input === "string" ? input : input.url;
      const full = new URL(url, urlBox.value).href;
      const text = await sendFetch(full);
      return new Response(text, { status:200, statusText:"OK" });
    };
    const origXhr = win.XMLHttpRequest;
    function ProxyX() {
      const xhr = new origXhr();
      const oldOpen = xhr.open;
      xhr.open = function(method, url, ...rest) {
        this._method = method;
        this._url = (new URL(url, urlBox.value)).href;
        return oldOpen.call(this, method, url, ...rest);
      };
      const oldSend = xhr.send;
      xhr.send = function(body) {
        sendFetch(this._url).then(resp => {
          if (this.onload) this.onload({ target: { responseText: resp } });
        });
      };
      return xhr;
    }
    win.XMLHttpRequest = ProxyX;
  }
})();
</script>
</body>
</html>
